# Expo App Framework
This project is a monorepo for building Expo apps with a shared framework.

Core functionality such as UI elements, hooks, constants, and utilities (collectively referred to as **components**) is centralized and reused across all Expo app projects.

By consolidating dependencies and common logic into a single framework, apps can be developed quickly without redefining the same building blocks.

*What is a monorepo: A monorepo is a single repository containing multiple distinct projects, with well-defined relationships.*

## End Goals
- Provide a ready-to-use template for quickly building new Expo apps.
- Maintain a shared framework of reusable components.
- Manage dependencies centrally (monorepo philosophy).
- Keep app projects lightweight by only adding app-specific code.
- Support native builds (`npx expo run:android` / `npx expo run:ios`) with Metro-powered hot reloading.

## Project Structure
### Overview
The monorepo is structured as follows:
```bash
root/
├── apps/
│   └── TemplateApp/        # example Expo app consuming the framework
├── packages/
│   └── Framework/          # core framework
│       ├── src/            # framework source code
│       └── ...
├── install.bat             # sync shared deps then install (Windows helper)
├── scripts/
│   └── sync-app-deps.cjs   # keeps app deps in sync with root overrides
└── package.json            # root scripts + shared version pins (overrides)
```

## High Level Overview
- **Framework**: Centralized shared components.
- **TemplateApp**: Example app + testbed for new features.
- **New apps**: Created by duplicating TemplateApp.
- **Dependencies**: Installed at root for shared packages, or per-app for unique needs.

## TemplateApp
TemplateApp demonstrates how to build an app on top of **Framework** and acts as a testbed for new shared components. Structure (excerpt):

```bash
apps/TemplateApp
├── android/                        # generated by native build
├── assets/
├── src/
│   ├── Screens/
│   │   ├── <ScreenName>.tsx        # app-specific screens
│   │   └── ScreenMap.ts            # screen registration for navigation
│   ├── App.tsx                     # root app entry
│   ├── index.ts
│   └── ...
├── app.config.js                   # Expo app configuration
├── babel.config.js                 # Babel (inherits shared base)
├── package.json                    # app-specific deps + mirrored shared deps
├── run-native-build-android.bat    # helper to build & run Android
└── tsconfig.json                   # TypeScript config
```

## Setup
### 1) Clone
````bash
git clone git@github.com:yct37785/ExpoAppFramework.git
cd ExpoAppFramework
````

*Windows tip: prefer a short path (e.g. `C:\Dev\ExpoAppFramework`) to avoid path length issues.*

### 2) Install (sync shared dependencies → install)
From the repo root:
````bash
./install.bat
````

What this does:
- Runs a script to mirror all shared dependency versions (from root overrides) into each app’s `package.json`.
- Updates the lockfile, then installs everything.

In addition to this initial setup step, this install script is to be run in various other scenarios — see next section for in-depth explanation.

### 3) Build & Run TemplateApp (Android example)
Make sure a device/emulator is ready, then from `apps/TemplateApp`:
````bash
./run-native-build-android.bat
````

This generates native projects (if needed), builds the app, installs it, and starts Metro for hot reload on your device/emulator.

## Shared Dependency Sync (No-Drift)
We centralize shared dependency versions in the root `package.json` under `overrides`. Example:

```json
{
  "overrides": {
    "expo": "~53.0.22",
    "react": "19.0.0",
    "react-native": "0.79.6",
    "react-native-reanimated": "~3.17.4",
    "react-native-screens": "~4.11.1"
    // ... more shared deps
  }
}
```

Each app lists the same shared packages in its own `package.json` under `dependencies`, but the versions are mirrored from root by the sync script. This is how we keep app manifests explicit (good for autolinking and tooling) while root remains the **single source of truth**.

### How the sync script works
On each run, for every app in `apps/*`:
- Read root overrides → the canonical shared dependencies + versions.
- Read the app’s current `dependencies` and its marker `x-sharedDependencies` (the previous shared set).
- Remove stale shared dependencies: anything that used to be shared (in `x-sharedDependencies`) but is no longer in root overrides.
- Preserve app-specific dependencies: anything not in overrides and not stale stays as-is.
- Mirror the exact versions from overrides into the app (overwriting any local pins).
- Refresh `x-sharedDependencies` to the current shared set.
- Write back only if something changed; then the installer updates the lockfile and installs.

### When to run it
- After adding/removing/bumping any shared dependencies in root overrides.
- After creating a new app (to inject the shared dependencies + versions).
- Any time you want to enforce a clean state across all apps.

*Note: By right only native packages need to be listed in the app's `package.json` for auto-linking to work, however for simplicity this script just duplicates the entire shared dependencies set.*

## Creating a New Client App
### Create Project
Simply duplicate `TemplateApp` under `apps/*` and rename it:

```
apps/
├── TemplateApp
└── MyNewApp
```

### Update Config
Change the duplicated app’s configs with your app name:

**app.config.js**:
````json
{
  "expo": {
    "name": "MyNewApp",
    "slug": "MyNewApp",
    ...
  "android": {
    "package": "com.anonymous.MyNewApp",
    ...
  }
}
````

**package.json**:
````json
{
  "name": "my-new-app"
  ...
}
````

### Run the Sync/Install
Inside your new app folder:
````bash
./run-native-build-android.bat
````

Just as with **TemplateApp**, this builds (if needed), installs and starts Metro hot reloading on your device/emulator.

*Tip: The monorepo .gitignore ignores all apps under `apps/*` except **TemplateApp**. Track your client app in a separate repo if you need source control for it.*

## Development
### Adding an App-Specific Dependency
If your app requires a specific package not part of the shared dependencies set, simply install them from within your app root:

````bash
cd app/MyNewApp
npx expo install <package1> <package2>
````

The installed packages will be hoisted (installed in root `node_modules`) when possible; conflicts will create a local copy under that app automatically - see next section for detailed explanation.

*Tip: When installing new packages use `npx expo install` *to get the latest expo compatibile version of each package.*

Run the sync/install script again from `root`:
````bash
./install.bat
````

## Dependency Installation & Hoisting

This repo uses **npm workspaces**. That means:
- Installs are hoisted to the root `node_modules` whenever possible (single lockfile, deduped installs).
- When two apps require **different versions** of the same app-specific **dependency**, npm will:
  - Keep one version hoisted at root `node_modules` (if compatible), and
  - Place the conflicting version inside that app’s own `node_modules` (nested, local to that app).

### Will app-specific dependencies leak into other builds?
No.
- Metro bundling only includes what an app imports in its dependency graph. A package being present at the root does not make it part of another app’s bundle unless that app imports it.
- Native autolinking only considers packages declared in the app’s `package.json`. If App B doesn’t list a native module, it won’t be linked into App B’s binary — even if it exists in root `node_modules`.
